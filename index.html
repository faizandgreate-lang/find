<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Smart Location Finder — Canvas Themes + Ambient</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Merriweather:wght@400;700&display=swap');

  :root{
    --card-bg: rgba(255,255,255,0.82);
    --btn-bg: rgba(255,255,255,0.94);
    --text-color: #111;
    --muted: rgba(0,0,0,0.55);
  }
  html,body{height:100%;margin:0;font-family:"Merriweather",serif;-webkit-font-smoothing:antialiased;}
  body{
    display:flex;flex-direction:column;align-items:center;min-height:100vh;
    color:var(--text-color);background:#fff;overflow:hidden;position:relative;transition:background .6s,color .6s;
  }

  /* background canvas (themes) */
  canvas.bgcanvas{
    position:fixed;left:0;top:0;width:100%;height:100%;z-index:0;pointer-events:none;
    -webkit-transform: translateZ(0);transform: translateZ(0);
  }

  header{ width:92%;max-width:920px;margin:14px auto 6px;display:flex;align-items:center;justify-content:center;position:relative;gap:20px;z-index:20; }
  .logo-wrap{ display:flex;align-items:center;gap:12px;position:relative; }
  .logo{ width:150px;border-radius:8px;box-shadow:0 8px 28px rgba(0,0,0,0.18); animation:logo-breathe 3s ease-in-out infinite; z-index:20; }
  @keyframes logo-breathe{ 0%,100%{transform:scale(1);opacity:.95} 50%{transform:scale(1.04);opacity:1} }

  .tiny-dot{ width:14px;height:14px;border-radius:50%;display:flex;align-items:center;justify-content:center;cursor:pointer; box-shadow:0 6px 18px rgba(0,0,0,0.12); transition:transform .18s; z-index:22; }
  .tiny-dot.left{ margin-right:-12px }
  .tiny-dot.right{ margin-left:-12px }
  .tiny-dot:active{ transform:scale(.92) }

  .controls{ width:92%;max-width:920px;margin:8px auto 6px;display:flex;flex-direction:column;align-items:center;gap:10px;z-index:18; }
  .btn{ padding:10px 20px;border-radius:10px;border:none;background:var(--btn-bg);font-weight:700;color:var(--text-color);box-shadow:0 8px 20px rgba(0,0,0,0.12);cursor:pointer;transition:transform .12s; min-width:170px }
  .btn:active{ transform:translateY(1px) }
  .btn.small{min-width:140px;padding:8px 14px}

  #map,#output{ width:92%;max-width:920px;border-radius:12px;box-shadow:0 10px 30px rgba(0,0,0,0.12);margin:12px 0;background:var(--card-bg);backdrop-filter: blur(6px);z-index:16;color:var(--text-color) }
  #map{ height:320px;overflow:hidden }
  #output{ padding:14px;font-size:14px; color:var(--text-color) }

  table{ width:100%;border-collapse:collapse }
  th,td{ padding:8px;border-bottom:1px solid rgba(0,0,0,0.06);text-align:left }
  th{ background:rgba(255,255,255,0.6);font-weight:700 }
  tr:nth-child(even){ background:rgba(255,255,255,0.02) }

  footer{ width:100%;text-align:center;padding:14px 8px 36px;color:var(--text-color);font-size:14px;z-index:16 }
  footer a{ color:var(--text-color); font-weight:700; text-decoration:none }
  footer a:hover{text-decoration:underline}

  /* theme button (moon/sun) */
  .theme-btn{ position:fixed;right:16px;bottom:16px;width:52px;height:52px;border-radius:12px;border:none;cursor:pointer;z-index:40;background:var(--btn-bg);box-shadow:0 12px 30px rgba(0,0,0,0.18);display:flex;align-items:center;justify-content:center; }
  .theme-btn:active{ transform:scale(.96) }

  /* moon/sun icon (SVG styled) */
  .icon { width:26px;height:26px;display:block; }

  /* sound toggle small button */
  .sound-btn{ position:fixed; right:16px; bottom:82px; width:44px;height:44px;border-radius:10px;border:none;cursor:pointer;z-index:40;background:var(--btn-bg);box-shadow:0 10px 26px rgba(0,0,0,0.15); display:flex;align-items:center;justify-content:center; }
  .sound-on{ filter: hue-rotate(0deg) }
  .sound-off{ opacity:0.45; filter:grayscale(0.7) }

  /* bloom animation */
  .bloom{ animation: bloomAnim .86s ease both; }
  @keyframes bloomAnim{ 0%{ filter:brightness(1); transform:scale(1) } 50%{ filter:brightness(1.45); transform:scale(1.02) } 100%{ filter:brightness(1); transform:scale(1) } }

  /* responsive */
  @media(max-width:520px){
    .logo{ width:120px }
    .tiny-dot{ width:12px;height:12px }
    .theme-btn{ right:12px;bottom:12px;width:46px;height:46px }
    .sound-btn{ right:12px;bottom:72px;width:40px;height:40px }
    #map{ height:260px }
    .btn{ min-width:140px }
  }
</style>
</head>
<body>

<canvas id="bgCanvas" class="bgcanvas"></canvas>

<header>
  <div class="logo-wrap" role="banner" aria-label="logo area">
    <div id="leftDot" class="tiny-dot" title="Spark" style="background:linear-gradient(180deg,#ffd6e6,#ff9fb0)"></div>
    <img class="logo" src="https://i.ibb.co/jPQz0mKf/Screenshot-2025-11-05-at-8-24-36-PM.png" alt="Logo">
    <div id="rightDot" class="tiny-dot" title="Ripple" style="background:linear-gradient(180deg,#d6f7ff,#6fefff)"></div>
  </div>
</header>

<div class="controls" role="region" aria-label="Main controls">
  <button class="btn small" onclick="getZip()">Get My ZIP Code</button>
  <button class="btn small" onclick="getAddress()">Get My Address</button>
  <button class="btn small" onclick="listNearby()">List Nearby Places</button>
</div>

<div id="map">
  <iframe id="osm-map" width="100%" height="100%" style="border:0" loading="lazy" allowfullscreen
    src="https://www.openstreetmap.org/export/embed.html?bbox=46.665,24.705,46.685,24.725&layer=mapnik&marker=24.7136,46.6753"></iframe>
</div>

<div id="output">Results will appear here</div>

<footer>
  <a href="https://www.instagram.com/mohammad_faizan_khan_/" target="_blank" rel="noopener">@mohammad_faizan_khan_</a> |
  <a href="https://mohammad.faizan.khan.linux-aios.com" target="_blank" rel="noopener">mohammad.faizan.khan.linux-aios.com</a>
  <div style="margin-top:10px; font-weight:600;">
    Thank you for visit — I made this to help peoples to find zipcode locations and near places by walking distance.
    <br>Myself Mohammad Faizan Khan — hope it will help.
  </div>
</footer>

<!-- Theme change button (moon/sun) -->
<button class="theme-btn" id="themeBtn" aria-label="change theme" title="Change Theme">
  <!-- sun/moon svg - will change color by CSS fill -->
  <svg class="icon" viewBox="0 0 24 24" id="themeIcon" aria-hidden="true">
    <defs></defs>
    <path id="iconPath" fill="currentColor" d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
  </svg>
</button>

<!-- Ambient sound toggle -->
<button class="sound-btn" id="soundBtn" title="Toggle ambient sound" aria-label="Toggle ambient sound">
  <svg width="18" height="18" viewBox="0 0 24 24" fill="none" id="soundIcon" aria-hidden="true">
    <path d="M11 5L6 9H3v6h3l5 4V5z" fill="currentColor"/>
    <path id="wave" d="M16.5 9.5c.8 1.2.8 2.8 0 4" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" fill="none" />
  </svg>
</button>

<script>
/* -------------------- Setup canvas & devicePixelRatio -------------------- */
const bg = document.getElementById('bgCanvas');
const ctx = bg.getContext('2d');
let DPR = Math.max(1, window.devicePixelRatio || 1);
let W = innerWidth, H = innerHeight;
function resizeCanvas(){
  W = innerWidth; H = innerHeight;
  DPR = Math.max(1, window.devicePixelRatio || 1);
  bg.width = Math.floor(W * DPR);
  bg.height = Math.floor(H * DPR);
  bg.style.width = W + 'px';
  bg.style.height = H + 'px';
  ctx.setTransform(DPR,0,0,DPR,0,0);
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

/* -------------------- Theme engine -------------------- */
const maxThemes = 10;
let themeIndex = Math.floor(Math.random() * maxThemes) + 1; // random on load
const themeBtn = document.getElementById('themeBtn');
const themeIcon = document.getElementById('themeIcon');
const themeIconPath = document.getElementById('iconPath');
const soundBtn = document.getElementById('soundBtn');

const leftDot = document.getElementById('leftDot');
const rightDot = document.getElementById('rightDot');

const UI = {
  setTextColor(color){
    document.documentElement.style.setProperty('--text-color', color);
  },
  setCardBg(v){
    document.documentElement.style.setProperty('--card-bg', v);
  },
  setBtnBg(v){
    document.documentElement.style.setProperty('--btn-bg', v);
  }
};

/* Theme descriptors: name, brightness preference (lightText true => light text on dark bg), ui colors, draw function assigned later */
const themeDefs = {
  1: { name:'Clouds', lightText:false, btnBg:'rgba(255,255,255,0.92)', cardBg:'rgba(255,255,255,0.86)', accent:'#1b1b1b', draw: null },
  2: { name:'Water Waves', lightText:false, btnBg:'rgba(240,250,255,0.9)', cardBg:'rgba(255,255,255,0.84)', accent:'#072b3a', draw: null },
  3: { name:'Volcano', lightText:true, btnBg:'rgba(20,10,8,0.6)', cardBg:'rgba(24,12,8,0.66)', accent:'#ffd29b', draw: null },
  4: { name:'Tornado', lightText:true, btnBg:'rgba(8,10,20,0.6)', cardBg:'rgba(10,12,22,0.62)', accent:'#cbd3ff', draw: null },
  5: { name:'Earthquake', lightText:true, btnBg:'rgba(12,10,8,0.6)', cardBg:'rgba(18,18,18,0.62)', accent:'#ffd7b6', draw: null },
  6: { name:'Galaxy', lightText:true, btnBg:'rgba(6,6,18,0.66)', cardBg:'rgba(10,10,28,0.64)', accent:'#e6e9ff', draw: null },
  7: { name:'Fire Sparks', lightText:true, btnBg:'rgba(18,6,6,0.6)', cardBg:'rgba(26,8,6,0.6)', accent:'#ffd36a', draw: null },
  8: { name:'Wind Flow', lightText:false, btnBg:'rgba(245,250,255,0.9)', cardBg:'rgba(255,255,255,0.86)', accent:'#0b3d4a', draw: null },
  9: { name:'Sandstorm', lightText:true, btnBg:'rgba(30,24,18,0.6)', cardBg:'rgba(28,22,16,0.62)', accent:'#ffe4b5', draw: null },
 10: { name:'Aurora', lightText:false, btnBg:'rgba(245,255,250,0.92)', cardBg:'rgba(255,255,255,0.84)', accent:'#042f2e', draw: null }
};

/* Utility functions */
function rand(min,max){ return Math.random()*(max-min)+min; }
function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }

/* --------------- Canvas theme implementations --------------- */
/* We'll implement one lightweight drawing function per theme — tuned for mobile */

/* 1 Cloud layer */
let cloudLayers = [];
function setupClouds(){
  cloudLayers = [];
  const count = Math.max(4, Math.floor(W/120));
  for(let i=0;i<count;i++){
    cloudLayers.push({ x: rand(-300,W), y: rand(H*0.03, H*0.55), s: rand(0.6,1.6), v: rand(0.04,0.25), alpha: rand(0.06,0.22) });
  }
}
function drawClouds(dt){
  // sky gradient
  const g = ctx.createLinearGradient(0,0,0,H);
  g.addColorStop(0,'#dff6ff'); g.addColorStop(1,'#c7f0ff');
  ctx.fillStyle = g; ctx.fillRect(0,0,W,H);
  // clouds
  cloudLayers.forEach(c=>{
    c.x += c.v * dt * 0.06;
    if(c.x - 300 > W) c.x = -300;
    ctx.globalAlpha = c.alpha;
    ctx.fillStyle = '#ffffff';
    drawCloud(c.x, c.y, c.s);
  });
  ctx.globalAlpha = 1;
}
function drawCloud(x,y,s){
  ctx.beginPath();
  ctx.ellipse(x, y, 130*s, 40*s, 0, 0, Math.PI*2);
  ctx.ellipse(x+60*s, y-10*s, 90*s, 34*s, 0,0,Math.PI*2);
  ctx.ellipse(x-60*s, y-6*s, 90*s, 34*s, 0,0,Math.PI*2);
  ctx.fill();
}

/* 2 Water waves */
let wavePhase=0, waveLayers=[];
function setupWater(){ wavePhase=0; waveLayers=[]; for(let i=0;i<3;i++) waveLayers.push({ amp: rand(8,28), speed: rand(0.0006,0.0022), yBase: H*0.6 + i*18 }) }
function drawWater(dt){
  wavePhase += dt*0.002;
  const g = ctx.createLinearGradient(0,0,0,H);
  g.addColorStop(0,'#bfefff'); g.addColorStop(1,'#8fd1ff');
  ctx.fillStyle = g; ctx.fillRect(0,0,W,H);
  ctx.globalAlpha = 0.86;
  waveLayers.forEach((w,i)=>{
    ctx.beginPath();
    for(let x=0;x<=W;x+=8){
      const y = w.yBase + Math.sin((x*0.01)+wavePhase*(1+i*0.5))* w.amp;
      if(x===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.lineTo(W,H); ctx.lineTo(0,H); ctx.closePath();
    ctx.fillStyle = `rgba(255,255,255,${0.06 + i*0.02})`; ctx.fill();
  });
  ctx.globalAlpha = 1;
}

/* 3 Volcano (lava blobs) */
let lavaBlobs=[];
function setupVolcano(){ lavaBlobs=[]; for(let i=0;i<12;i++) lavaBlobs.push({ x: W*0.52 + rand(-80,80), y: H*0.66 + rand(-30,40), vx: rand(-0.3,0.3), vy: rand(-1.6,-0.5), life: rand(60,160) }) }
function drawVolcano(dt){
  // dark smoky sky
  const g = ctx.createLinearGradient(0,0,0,H); g.addColorStop(0,'#301407'); g.addColorStop(1,'#4b1d0b');
  ctx.fillStyle = g; ctx.fillRect(0,0,W,H);
  // mountain
  ctx.fillStyle = '#22110b';
  ctx.beginPath(); ctx.moveTo(0,H); ctx.lineTo(W*0.35,H*0.6); ctx.lineTo(W*0.5,H*0.72); ctx.lineTo(W*0.65,H*0.58); ctx.lineTo(W,H); ctx.closePath(); ctx.fill();
  // lava blobs
  lavaBlobs.forEach(b=>{
    b.x += b.vx * dt * 0.06; b.y += b.vy * dt * 0.06; b.vy += 0.04; b.life--;
    if(b.life <= 0){ b.x = W*0.52 + rand(-80,80); b.y = H*0.66 + rand(-30,40); b.vx = rand(-0.4,0.4); b.vy = rand(-1.4,-0.6); b.life = rand(60,160); }
    const grd = ctx.createRadialGradient(b.x,b.y,0,b.x,b.y,30); grd.addColorStop(0,'rgba(255,245,200,0.95)'); grd.addColorStop(0.35,'rgba(255,110,20,0.8)'); grd.addColorStop(1,'rgba(255,40,0,0)');
    ctx.fillStyle = grd; ctx.beginPath(); ctx.arc(b.x,b.y,18,0,Math.PI*2); ctx.fill();
  });
}

/* 4 Tornado: swirling funnel + dust */
let tornadoParticles=[];
function setupTornado(){ tornadoParticles=[]; for(let i=0;i<120;i++) tornadoParticles.push({ ang: rand(0,Math.PI*2), r: rand(10, W*0.6), speed: rand(0.0008,0.003), y: rand(H*0.2,H*0.9) }) }
function drawTornado(dt){
  // sky base
  const g = ctx.createLinearGradient(0,0,0,H); g.addColorStop(0,'#7b8a99'); g.addColorStop(1,'#4a4f55');
  ctx.fillStyle = g; ctx.fillRect(0,0,W,H);
  // dust particles swirling
  ctx.globalAlpha = 0.9;
  tornadoParticles.forEach(p=>{
    p.ang += p.speed * dt * 0.02;
    p.r *= 0.9999;
    const cx = W*0.5 + Math.cos(p.ang)*p.r* (0.0005 + (p.y/H));
    const cy = p.y;
    ctx.fillStyle = 'rgba(200,180,160,0.12)';
    ctx.beginPath(); ctx.arc(cx,cy,1.2,0,Math.PI*2); ctx.fill();
  });
  ctx.globalAlpha = 1;
  // funnel overlay
  ctx.fillStyle = 'rgba(40,40,40,0.08)';
  ctx.beginPath();
  ctx.moveTo(W*0.45, H*0.15); ctx.lineTo(W*0.55,H*0.15); ctx.lineTo(W*0.75,H); ctx.lineTo(W*0.25,H); ctx.closePath(); ctx.fill();
}

/* 5 Earthquake: shaking particles & gradient */
let quakeParticles=[];
function setupEarthquake(){ quakeParticles=[]; const count=Math.max(80,Math.floor(W/8)); for(let i=0;i<count;i++) quakeParticles.push({x:rand(0,W),y:rand(0,H),vx:rand(-0.2,0.2),vy:rand(-0.2,0.2),r:rand(0.6,1.6)}) }
function drawEarthquake(dt){
  // deep dark
  const g = ctx.createLinearGradient(0,0,0,H); g.addColorStop(0,'#0a0a0a'); g.addColorStop(1,'#231b16');
  ctx.fillStyle = g; ctx.fillRect(0,0,W,H);
  // particles jitter
  quakeParticles.forEach(p=>{
    p.x += (Math.random()-0.5)*1.8; p.y += (Math.random()-0.5)*1.8;
    ctx.fillStyle = 'rgba(255,255,255,0.06)';
    ctx.beginPath(); ctx.arc(p.x,p.y,p.r,0,Math.PI*2); ctx.fill();
  });
}

/* 6 Galaxy: starfield + spiral */
let stars=[];
function setupGalaxy(){ stars=[]; for(let i=0;i<100;i++) stars.push({x:rand(0,W),y:rand(0,H),r:rand(0.3,1.8),vx:rand(-0.01,0.01),vy:rand(-0.01,0.01),alpha:rand(0.2,1)}) }
function drawGalaxy(dt){
  const g = ctx.createLinearGradient(0,0,0,H); g.addColorStop(0,'#05021a'); g.addColorStop(1,'#0b1540');
  ctx.fillStyle = g; ctx.fillRect(0,0,W,H);
  stars.forEach(s=>{
    s.x += s.vx * dt * 0.02; s.y += s.vy * dt * 0.02;
    if(s.x<0)s.x=W; if(s.x>W)s.x=0; if(s.y<0)s.y=H; if(s.y>H)s.y=0;
    ctx.globalAlpha = s.alpha;
    ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(s.x,s.y,s.r,0,Math.PI*2); ctx.fill();
  });
  ctx.globalAlpha = 1;
}

/* 7 Fire Sparks */
let sparks=[];
function setupSparks(){ sparks=[]; for(let i=0;i<40;i++) sparks.push({x:rand(0,W),y:rand(H*0.6,H),vx:rand(-0.3,0.3),vy:rand(-1.5,-0.4),life: rand(40,140),r:rand(1,3)}) }
function drawSparks(dt){
  const g = ctx.createLinearGradient(0,0,0,H); g.addColorStop(0,'#150407'); g.addColorStop(1,'#2d0c06');
  ctx.fillStyle = g; ctx.fillRect(0,0,W,H);
  sparks.forEach(s=>{
    s.x += s.vx * dt * 0.06; s.y += s.vy * dt * 0.06; s.vy += 0.04; s.life--;
    if(s.life<=0){ s.x=rand(W*0.4,W*0.6); s.y=H*0.6 + rand(-20,40); s.vx=rand(-0.3,0.3); s.vy=rand(-1.5,-0.4); s.life=rand(40,140); }
    const grd = ctx.createRadialGradient(s.x,s.y,0,s.x,s.y,12); grd.addColorStop(0,'rgba(255,255,200,0.95)'); grd.addColorStop(0.5,'rgba(255,120,40,0.6)'); grd.addColorStop(1,'rgba(255,40,0,0)');
    ctx.fillStyle = grd; ctx.beginPath(); ctx.arc(s.x,s.y,s.r*2,0,Math.PI*2); ctx.fill();
  });
}

/* 8 Wind Flow: soft lines */
let windLines=[];
function setupWind(){ windLines=[]; const count=Math.max(6,Math.floor(W/160)); for(let i=0;i<count;i++) windLines.push({off:rand(0,Math.PI*2),amp:rand(20,120),speed:rand(0.0006,0.002),y:rand(H*0.15,H*0.7)}) }
function drawWind(dt){
  const g = ctx.createLinearGradient(0,0,0,H); g.addColorStop(0,'#eef9ff'); g.addColorStop(1,'#dff4ff');
  ctx.fillStyle = g; ctx.fillRect(0,0,W,H);
  ctx.globalAlpha = 0.95;
  windLines.forEach((l,i)=>{
    l.off += l.speed * dt;
    ctx.beginPath();
    for(let x=0;x<=W;x+=8){
      const y = l.y + Math.sin((x*0.01) + l.off) * l.amp * 0.4;
      if(x===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.strokeStyle = `rgba(255,255,255,${0.08 + i*0.02})`; ctx.lineWidth = 2; ctx.stroke();
  });
  ctx.globalAlpha = 1;
}

/* 9 Sandstorm: drifting grain */
let sand=[];
function setupSand(){ sand=[]; const count=Math.max(120,Math.floor(W/6)); for(let i=0;i<count;i++) sand.push({x:rand(0,W), y:rand(0,H), vx:rand(-0.3,-0.05), vy:rand(-0.02,0.04), r:rand(0.3,1.2)}) }
function drawSand(dt){
  const g = ctx.createLinearGradient(0,0,0,H); g.addColorStop(0,'#f7ecd6'); g.addColorStop(1,'#e6d5b2');
  ctx.fillStyle = g; ctx.fillRect(0,0,W,H);
  ctx.globalAlpha = 0.9;
  sand.forEach(s=>{
    s.x += s.vx * dt * 0.02; s.y += s.vy * dt * 0.02;
    if(s.x<0) s.x=W; if(s.x>W) s.x=0; if(s.y<0) s.y=H; if(s.y>H) s.y=0;
    ctx.fillStyle = 'rgba(120,85,44,0.25)'; ctx.beginPath(); ctx.arc(s.x,s.y,s.r,0,Math.PI*2); ctx.fill();
  });
  ctx.globalAlpha = 1;
}

/* 10 Aurora: soft color bands */
let auroras=[];
function setupAurora(){ auroras=[]; for(let i=0;i<4;i++) auroras.push({phase:rand(0,Math.PI*2), amp:rand(20,110), speed:rand(0.0008,0.0022), hue:rand(120,200), yBase:rand(H*0.16,H*0.46)}) }
function drawAurora(dt){
  const g = ctx.createLinearGradient(0,0,0,H); g.addColorStop(0,'#021018'); g.addColorStop(1,'#041d1f');
  ctx.fillStyle = g; ctx.fillRect(0,0,W,H);
  auroras.forEach(a=>{
    a.phase += a.speed * dt;
    ctx.globalAlpha = 0.14;
    ctx.beginPath();
    for(let x=0;x<=W;x+=10){
      const y = a.yBase + Math.sin((x*0.007)+a.phase) * a.amp;
      if(x===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.lineTo(W,H); ctx.lineTo(0,H); ctx.closePath();
    ctx.fillStyle = `hsl(${a.hue} 80% 60%)`;
    ctx.fill();
  });
  ctx.globalAlpha = 1;
}

/* Dispatcher */
const themeFns = {
  1: { setup: setupClouds, draw: drawClouds },
  2: { setup: setupWater, draw: drawWater },
  3: { setup: setupVolcano, draw: drawVolcano },
  4: { setup: setupTornado, draw: drawTornado },
  5: { setup: setupEarthquake, draw: drawEarthquake },
  6: { setup: setupGalaxy, draw: drawGalaxy },
  7: { setup: setupSparks, draw: drawSparks },
  8: { setup: setupWind, draw: drawWind },
  9: { setup: setupSand, draw: drawSand },
 10: { setup: setupAurora, draw: drawAurora }
};

/* initialize theme */
function initTheme(i){
  // UI color choices
  const def = themeDefs[i];
  UI.setTextColor(def.lightText ? '#f5f7fb' : '#111');
  UI.setCardBg(def.cardBg);
  UI.setBtnBg(def.btnBg);
  // set icon color
  document.getElementById('themeIcon').style.color = def.accent || '#111';
  // setup theme canvas resources
  if(themeFns[i] && themeFns[i].setup) themeFns[i].setup();
}
initTheme(themeIndex);

/* draw loop */
let last = performance.now();
function loop(t){
  const dt = t - last; last = t;
  if(themeFns[themeIndex] && themeFns[themeIndex].draw) themeFns[themeIndex].draw(dt);
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

/* theme change: cycle and re-init + bloom */
function changeTheme(){
  themeIndex = themeIndex >= maxThemes ? 1 : themeIndex + 1;
  initTheme(themeIndex);
  // bloom
  document.body.classList.add('bloom');
  setTimeout(()=>document.body.classList.remove('bloom'),860);
}
themeBtn.addEventListener('click', ()=>{ changeTheme(); /* ensure audio allowed later */ });

/* Start with random theme at load (already set), also ensure small initial reflow */
window.addEventListener('load', ()=>{ initTheme(themeIndex); });

/* --------------- Interactive Spark and Ripple --------------- */
/* spark explosion uses overlay canvas then removes */
function spawnSpark(x,y){
  const canvas = document.createElement('canvas'); canvas.className='overlay';
  canvas.width = innerWidth * DPR; canvas.height = innerHeight * DPR;
  canvas.style.width = innerWidth + 'px'; canvas.style.height = innerHeight + 'px';
  canvas.style.position = 'fixed'; canvas.style.left='0'; canvas.style.top='0'; canvas.style.zIndex = 80; canvas.style.pointerEvents='none';
  const c = canvas.getContext('2d'); c.setTransform(DPR,0,0,DPR,0,0);
  document.body.appendChild(canvas);
  const parts = [];
  const count = 44;
  for(let i=0;i<count;i++){
    const a = Math.random()*Math.PI*2;
    parts.push({ x, y, vx:Math.cos(a)*(1+Math.random()*3), vy:Math.sin(a)*(1+Math.random()*3), life: 50+Math.random()*40, size: 1+Math.random()*3, col: `hsl(${rand(20,60)},100%,70%)` });
  }
  function anim(){
    c.clearRect(0,0,canvas.width,canvas.height);
    for(let i=parts.length-1;i>=0;i--){
      const p = parts[i];
      p.x += p.vx; p.y += p.vy; p.vy += 0.06; p.life--;
      c.globalAlpha = Math.max(0, p.life / 100);
      c.fillStyle = p.col; c.beginPath(); c.arc(p.x,p.y,Math.max(0.3, p.size),0,Math.PI*2); c.fill();
      if(p.life<=0) parts.splice(i,1);
    }
    if(parts.length>0) requestAnimationFrame(anim); else document.body.removeChild(canvas);
  }
  anim();
}
leftDot.addEventListener('click', (e)=>{
  const logo = document.querySelector('.logo'); const r = logo.getBoundingClientRect();
  const cx = r.left + r.width/2 + rand(-6,6), cy = r.top + r.height/2 + rand(-6,6);
  spawnSpark(cx,cy);
  themeBtn.animate([{transform:'scale(1)'},{transform:'scale(.94)'},{transform:'scale(1)'}],{duration:320});
});

/* ripple rings */
function spawnRipple(x,y){
  const canvas = document.createElement('canvas'); canvas.className='overlay';
  canvas.width = innerWidth * DPR; canvas.height = innerHeight * DPR;
  canvas.style.width = innerWidth + 'px'; canvas.style.height = innerHeight + 'px';
  canvas.style.position = 'fixed'; canvas.style.left='0'; canvas.style.top='0'; canvas.style.zIndex = 80; canvas.style.pointerEvents='none';
  const c = canvas.getContext('2d'); c.setTransform(DPR,0,0,DPR,0,0);
  document.body.appendChild(canvas);
  const rings = [{r:8,lw:40,life:0,max:120,alpha:0.9},{r:28,lw:32,life:0,max:140,alpha:0.75},{r:50,lw:22,life:0,max:160,alpha:0.55}];
  function anim(){
    c.clearRect(0,0,canvas.width,canvas.height);
    for(let i=0;i<rings.length;i++){
      const s = rings[i]; s.life += 3.6;
      const prog = s.life / s.max; if(prog>1) continue;
      c.beginPath(); c.lineWidth = Math.max(1, s.lw*(1-prog)); c.strokeStyle = `rgba(255,255,255,${Math.max(0, s.alpha*(1-prog))})`;
      c.arc(x,y, s.r + s.life*0.8, 0, Math.PI*2); c.stroke();
    }
    if(rings.some(r=>r.life < r.max)) requestAnimationFrame(anim); else document.body.removeChild(canvas);
  }
  anim();
}
rightDot.addEventListener('click', ()=>{
  const logo = document.querySelector('.logo'); const r = logo.getBoundingClientRect();
  const cx = r.left + r.width/2 + rand(-6,6), cy = r.top + r.height/2 + rand(-6,6);
  spawnRipple(cx,cy);
  themeBtn.animate([{opacity:1},{opacity:.6},{opacity:1}],{duration:320});
});

/* --------------- Ambient sound (WebAudio) --------------- */
/* lightweight ambient generator: noise + slow oscillator + filter per theme */
const AudioCtx = window.AudioContext || window.webkitAudioContext;
let audioCtx = null;
let masterGain = null;
let ambientNodes = [];

function ensureAudio(){
  if(!audioCtx){ audioCtx = new AudioCtx(); masterGain = audioCtx.createGain(); masterGain.gain.value=0.0; masterGain.connect(audioCtx.destination); }
}

/* create theme-specific ambient */
function startAmbientForTheme(i){
  stopAmbient();
  ensureAudio();
  const t = themeDefs[i];
  // base noise (wind/sea) using BufferSource white noise filtered
  const bufferSize = 2 * audioCtx.sampleRate;
  const noiseBuffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
  const output = noiseBuffer.getChannelData(0);
  for (let i2 = 0; i2 < bufferSize; i2++) output[i2] = Math.random() * 2 - 1;
  const noise = audioCtx.createBufferSource(); noise.buffer = noiseBuffer; noise.loop = true;
  const noiseFilter = audioCtx.createBiquadFilter(); noiseFilter.type = 'bandpass';
  // tune noise filter per theme
  const lowMap = {1:200,2:600,3:200,4:350,5:120,6:80,7:200,8:450,9:300,10:140};
  noiseFilter.frequency.value = lowMap[i] || 300;
  noiseFilter.Q.value = 0.8;
  const noiseGain = audioCtx.createGain(); noiseGain.gain.value = 0.05;
  noise.connect(noiseFilter); noiseFilter.connect(noiseGain); noiseGain.connect(masterGain);
  noise.start();

  // slow sine drone
  const osc = audioCtx.createOscillator(); osc.type = 'sine';
  const freqMap = {1:200,2:120,3:70,4:90,5:60,6:50,7:100,8:220,9:90,10:80};
  osc.frequency.value = freqMap[i] || 110;
  const oscGain = audioCtx.createGain(); oscGain.gain.value = 0.02;
  osc.connect(oscGain); oscGain.connect(masterGain); osc.start();

  // subtle LFO for moving filter
  const lfo = audioCtx.createOscillator(); lfo.frequency.value = 0.05; // very slow
  const lfoGain = audioCtx.createGain(); lfoGain.gain.value = 300;
  if(noiseFilter.frequency) { lfo.connect(lfoGain); lfoGain.connect(noiseFilter.frequency); lfo.start(); }

  ambientNodes = [noise, noiseFilter, noiseGain, osc, oscGain, lfo, lfoGain];
  // fade in
  masterGain.gain.cancelScheduledValues(audioCtx.currentTime);
  masterGain.gain.setValueAtTime(0, audioCtx.currentTime);
  masterGain.gain.linearRampToValueAtTime(1.0, audioCtx.currentTime + 1.6);
}

/* stop ambient */
function stopAmbient(){
  if(!audioCtx) return;
  masterGain.gain.cancelScheduledValues(audioCtx.currentTime);
  masterGain.gain.setTargetAtTime(0, audioCtx.currentTime, 0.6);
  // stop nodes after fade
  setTimeout(()=>{ ambientNodes.forEach(n => { try{ n.stop && n.stop(); n.disconnect && n.disconnect(); }catch(e){} }); ambientNodes = []; }, 900);
}

/* audio toggle state */
let audioOn = false;
soundBtn.addEventListener('click', async ()=>{
  // user gesture
  if(!audioCtx){ ensureAudio(); }
  if(!audioOn){
    // resume context for autoplay policies
    try{ await audioCtx.resume(); }catch(e){}
    startAmbientForTheme(themeIndex);
    audioOn = true; soundBtn.classList.remove('sound-off'); soundBtn.classList.add('sound-on');
  } else {
    stopAmbient();
    audioOn = false; soundBtn.classList.remove('sound-on'); soundBtn.classList.add('sound-off');
  }
});

/* change ambient when theme changes (if audioOn) */
function updateAmbientForTheme(i){
  if(audioOn){ startAmbientForTheme(i); }
}

/* hook into changeTheme to update audio & UI colors */
function initTheme(i){
  const def = themeDefs[i];
  UI.setTextColor(def.lightText ? '#f7f8fb' : '#111');
  UI.setCardBg(def.cardBg);
  UI.setBtnBg(def.btnBg);
  // update tiny-dot colors for contrast
  leftDot.style.background = def.lightText ? 'linear-gradient(180deg,#ffe6b3,#ffb48a)' : 'linear-gradient(180deg,#fff,#ddd)';
  rightDot.style.background = def.lightText ? 'linear-gradient(180deg,#bfefff,#6fefff)' : 'linear-gradient(180deg,#fff,#ddd)';
  // icon color
  themeIcon.style.color = def.accent || (def.lightText ? '#fff' : '#111');
  // initialize theme resources
  if(themeFns[i] && themeFns[i].setup) themeFns[i].setup();
  // ambient
  updateAmbientForTheme(i);
}

/* set initial theme at load, random */
initTheme(themeIndex);

/* override changeTheme to also init theme */
function changeTheme(){
  themeIndex = themeIndex >= maxThemes ? 1 : themeIndex + 1;
  initTheme(themeIndex);
  // bloom
  document.body.classList.add('bloom');
  setTimeout(()=>document.body.classList.remove('bloom'),860);
}
themeBtn.onclick = changeTheme;

/* --------------- Map & GEO functions (unchanged) --------------- */
function getLocation() {
  return new Promise((resolve, reject) => {
    if(navigator.geolocation){
      navigator.geolocation.getCurrentPosition(pos => resolve({lat: pos.coords.latitude, lon: pos.coords.longitude}),
      err => reject("Location access denied or unavailable"));
    } else reject("Geolocation not supported");
  });
}
async function getZip() {
  try {
    const loc = await getLocation();
    const res = await fetch(`https://nominatim.openstreetmap.org/reverse?lat=${loc.lat}&lon=${loc.lon}&format=json`);
    const data = await res.json();
    document.getElementById('output').innerText = "ZIP Code: " + (data.address && data.address.postcode ? data.address.postcode : "Not found");
    updateMap(loc.lat, loc.lon);
  } catch(err) { document.getElementById('output').innerText = err; }
}
async function getAddress() {
  try {
    const loc = await getLocation();
    const res = await fetch(`https://nominatim.openstreetmap.org/reverse?lat=${loc.lat}&lon=${loc.lon}&format=json`);
    const data = await res.json();
    document.getElementById('output').innerText = "Address: " + (data.display_name || "Not found");
    updateMap(loc.lat, loc.lon);
  } catch(err) { document.getElementById('output').innerText = err; }
}
function getDistance(lat1, lon1, lat2, lon2){
  const R = 6371;
  const dLat = (lat2-lat1)*Math.PI/180;
  const dLon = (lon2-lon1)*Math.PI/180;
  const a = Math.sin(dLat/2)**2 + Math.cos(lat1*Math.PI/180)*Math.cos(lat2*Math.PI/180)*Math.sin(dLon/2)**2;
  const c = 2*Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
  return (R*c).toFixed(2);
}
async function listNearby() {
  try {
    const loc = await getLocation();
    updateMap(loc.lat, loc.lon);
    const query = `[out:json];node(around:1000,${loc.lat},${loc.lon})[amenity];out;`;
    const res = await fetch(`https://overpass-api.de/api/interpreter?data=${encodeURIComponent(query)}`);
    const data = await res.json();
    if(data.elements && data.elements.length > 0){
      let html = `<table><tr><th>Place</th><th>Type</th><th>Dist (km)</th><th>Walk (min)</th></tr>`;
      data.elements.slice(0,20).forEach(el=>{
        const name = (el.tags && (el.tags['name:en'] || el.tags.name)) || (el.tags ? el.tags.amenity : "Place");
        const type = (el.tags && el.tags.amenity) || "Unknown";
        const dist = getDistance(loc.lat, loc.lon, el.lat, el.lon);
        const time = Math.ceil(dist / 0.083);
        const link = `https://www.openstreetmap.org/?mlat=${el.lat}&mlon=${el.lon}#map=18/${el.lat}/${el.lon}`;
        html += `<tr><td style="word-break:break-word"><a href="${link}" target="_blank" rel="noopener">${escapeHtml(name)}</a></td><td>${escapeHtml(type)}</td><td>${dist}</td><td>${time}</td></tr>`;
      });
      html += `</table>`;
      document.getElementById('output').innerHTML = html;
    } else document.getElementById('output').innerText = "No nearby places found";
  } catch(err){ document.getElementById('output').innerText = "Failed to fetch nearby places"; }
}
function updateMap(lat, lon){
  document.getElementById('osm-map').src = `https://www.openstreetmap.org/export/embed.html?bbox=${lon-0.01},${lat-0.01},${lon+0.01},${lat+0.01}&layer=mapnik&marker=${lat},${lon}`;
}
function escapeHtml(s){ return String(s).replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])); }

/* --------------- Start drawing loop using themeFns --------------- */
let lastTime = performance.now();
function drawLoop(now){
  const dt = now - lastTime; lastTime = now;
  if(themeFns[themeIndex] && themeFns[themeIndex].draw) themeFns[themeIndex].draw(dt);
  requestAnimationFrame(drawLoop);
}
requestAnimationFrame(drawLoop);

/* Ensure canvas resizes correctly and re-setup theme when window changes */
window.addEventListener('resize', ()=>{
  resizeCanvas();
  if(themeFns[themeIndex] && themeFns[themeIndex].setup) themeFns[themeIndex].setup();
});

/* Start audio context on first user gesture to comply with autoplay policies */
document.addEventListener('click', async function initAudioOnFirstGesture(){
  if(!audioCtx){
    try{ audioCtx = new (window.AudioContext || window.webkitAudioContext)(); masterGain = audioCtx.createGain(); masterGain.gain.value = 0; masterGain.connect(audioCtx.destination); }
    catch(e){ /* no audio support */ }
    // remove this listener after first gesture
    document.removeEventListener('click', initAudioOnFirstGesture);
  }
}, { once:true });

</script>
</body>
</html>
